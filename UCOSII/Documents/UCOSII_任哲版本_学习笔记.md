# 嵌入式实时操作系统 μCOS-II 原理及应用 -- 任哲

- [嵌入式实时操作系统 μCOS-II 原理及应用 -- 任哲](#嵌入式实时操作系统-μcos-ii-原理及应用----任哲)
  - [前言](#前言)
  - [第一章：嵌入式实时操作系统的概念](#第一章嵌入式实时操作系统的概念)
  - [第二章：预备知识](#第二章预备知识)
    - [开发工具](#开发工具)

## 前言

- Linux 相当庞大，没有一定基础，直接学习比较难；
- uCOS 奠定基础，再去学习 Linux 可能更容易理解；
- 操作系统都是触类旁通的，学会一款，其他上手很快；

## 第一章：嵌入式实时操作系统的概念

- 它是多任务的，抢占式的，且要满足实时性，即任务切换时间应与系统任务数量无关，且中断延迟的时间是可预知尽量短；

![img](./img/2022-11-20_1_ucos_form.jpg)

## 第二章：预备知识

### 开发工具

好的开发工具：GCC；make 工具及 makefile；

- 任哲这本书里面用的是 “Borland C 3.1” 这是一款在 PC 编译 C 文件的软件
- 这本书的出版时间是 2006 年，BC3.1 是一款比较老的软件，基本现在都淘汰不用
- 现在比较流行的是 GCC 所以，要先学习 GCC 编译 C 文件

学习 GCC

参考网址：https://blog.csdn.net/qq_42475711/article/details/85224010

- GCC（GNU C Compiler）即GNU c编译器；它是编译器，用来编译 C 语言；
- 现在 GCC 拓展称为（GNU Compiler Collection）即 GNU 编译器套件；可以编译 C,C++,Java 等；所以称为编译器套件
- GUN 是一个技术组织，建立自由软件基金会，发行了 GPL（GUN General Public License）GUN 通用公共授权书
  - 后来 Linux 遵循 GPL，自由软件从此迅速发展，Linux 越来越强大

下载安装 GCC：https://osdn.net/projects/mingw/releases/

- MinGW（Minimalist GUN for Windows）：Windows 上的极简 GUN
- 安装好后，把 MinGM 的 bin 目录加入到环境变量的 path 中，这样 dos 在任意目录都可以调用 GCC
  - 添加环境变量的作用就是让 dos 或者其他软件可以访问到环境变量里面的内容
  - Windows 运行程序会从环境变量中浏览可执行命令 cmdlet

GCC 常用指令讲解

- 用 GCC 在 Windows 上编译 .c 文件并非直接生成 .exe 文件（Linux上为*.out）中间还经历了预处理、编译和汇编几个过程
- .c 预处理 .i 编译 .s 汇编 .o 连接 .exe(out)

![img](./img/2022-11-29_2_GCC_process.jpg)

- gcc Demo.c; Demo.c 文件 -> a.exe； a.exe 是默认生成的文件名；
- -o（指定文件名） 指令：
  - 使用命令：gcc Demo.c -o Demo.exe; 指定文件名
  - 使用命令：gcc Demo.c -o ..\Demo.exe; 指定生成文件目录和文件名
- -E（预处理）指令：
  - 将执行预处理操作也即生成 *.i 文件, gcc 编译器将对 # 开头的指令进行解析
  - 使用命令：gcc -E Demo.c -o Demo.i; 把 Demo.c 预处理成 Demo.i
  - 预处理阶段的动作：把所有注释都去掉；头文件被包含，自动添加函数声明；宏常量替换；宏代码替换；
    - 因此，反编译回来的代码是没有注释的
  - 预处理会把工程整合成一个大文件；但是，不会检查语法错误
  - 使用命令：gcc -E Demo.c; 不指定输出的文件名时内容将会直接输出到Dos框中，而不会产生文件

![img](./img/2022-11-29_2_GCC_E.jpg)

- -S（编译）指令：
  - 将 .i 文件中源码转化为汇编代码 .s 文件
  - 使用命令：gcc -S Demo.i -o Demo.s; Demo.s 文件记录 Demo.c 源码转化的汇编代码
  - 使用命令：gcc -S Demo.i 即不指定输出文件名，默认还是会在当前目录下产生文件 Demo.s
  - 如果此时出现语法错误，系统会提示错误；所以，对语法的检查是在编译阶段进行的
- -c（汇编）指令：
  - 将 .s 文件中的汇编源码转化为机器能执行的二进制机器码，生成文件 .o
  - 使用命令：gcc -c Demo.s -o Demo.o; Demo.o 为二进制文件,基本无法阅读
- gcc *.o（链接）指令：
  - 二进制文件 Demo.o 虽然已经机器码，但仍然无法运行；还要链接成 .exe 文件
  - 使用命令：gcc Demo.o -o Demo.exe
    - 在预处理和编译只检查函数声明，语法错误，函数调用处符合函数原型；不会检查函数定义
    - 而链接就是把所有函数原型关联起来，组成可运行的程序
  - 这里链接会报错，因为在链接过程中，找不到函数定义，无法关联；函数定义在另一个 .c 文件中
    - 标准库函数可以编译，是因为 gcc 在链接的时候，已经包含了路径
    - 自己写的 .c 文件，并没有包含进去
  - 成功链接的方法：
    - 1、去掉外部函数，或移动到 Dome.c 中
    - 2、将 Test.c 封装成静态库供其调用
  - 2、将 Test.c 封装成静态库供其调用
    - 使用命令：gcc -c Test.c -o Test.o 生成 Test.o 二进制文件；这里编译器自动对 Test.c 做预处理和编译操作
    - 使用命令：ar -rcs libTest.a Test.o  生成静态库
    - 使用命令：gcc Demo.o libTest.a -o Demo.exe 链接的时候，指明需要的静态库
